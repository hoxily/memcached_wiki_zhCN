# 新概述

这是个什么东西？

* Memcached
* 用更多的话来解说memcached
* 我启用了它但是应用程序并没有跑得更快！！！
* 这玩意儿是由什么构成的？
* 它的设计哲学为何？
* Memcached是如何进化的？

## Memcached

自由、开源、高性能、分布式的内存对象缓存系统，本质上是通用的，但是专注于通过缓解数据库负荷来加速动态WEB应用。

Memcached 是一个在内存中的键-值存储器，用于存储来自数据库调用、API调用以及页面渲染得到的小块的任意类型的数据(字符串，对象)。

Memcached虽然简单但是功能强大。

它的简单设计加快了部署、简化了开发，并且解决了许多面临大数据缓存时遇到的问题。

它的API可以在大部分流行的语言中使用。

本质上它是一个简单的键-值存储器。

## 用更多的话来解说Memcached

见 [http://memcached.org](http://memcached.org) about页面以获得一个简短的概述。

## 我启用了它但是应用程序并没跑得更快！！！

Memcached 是一个开发者工具，而不是一个“代码优化器”，也不是数据库中间件。

如果你想配置你下载的或者购买的应用程序使用memcached，你最好赌一下采用他们的方式并且阅读你的应用有关如何使用memcached的文档。赌输了的话也就是这些文档没能帮到你。

## 这玩意儿是由什么构成的？

客户端软件，它们有着一陀可用的memcached服务器。

一个基于客户端的hash算法，这算法能根据输入的“键”选择一个合适的服务器。

服务端软件，它们在内部的hash表里面存储着你的键-值。

服务端算法，该算法用于确定何时可以扔掉旧的数据（如果内存不够了），或者重用内存。

## 它的设计哲学为何？

简单的键-值存储器

服务器不关心你的数据长啥模样。

数据项是由键、过期时间、选项标志以及原始数据构成。

它不懂里面的数据结构；

你必须上传预先序列化过的数据。

某些命令（incr/decr)可能会操作基础数据，但是这些命令的实现是非常单纯的。

## 智能的达成一半靠客户端，另一半靠服务端

“memcached 的实现” 是有部分在客户端实现，有部分在服务端实现。

客户端懂得如何发送数据项到特定的服务器，当无法联系服务器时该做什么以及如何用键从服务器那里取得值。

服务端懂得如何接收数据项和如何处理过期数据项。

## 服务器互相之间没有连接

一般上，memcached服务器并不知道对方的存在。

服务器之间没有对话，没有同步，没有广播。

这种相互之间联系的缺乏，意味着增加更多的服务器将会产生你所预期的更多的产生力。

这个规则可能有例外，但是它们只是例外并且会被小心仔细地对待。

## 任何东西都是O(1)的时间复杂度

对任何能处理的，memcached命令都是O(1)的时间复杂度。

基本上每次每个命令花费相同的时间去处理，并且不太可能注意到任何地方的速度下降。

这得追溯到“简单的键-值存储”原理，因为你并不想处理那个被成百上千个Web服务器同时访问的缓存服务里面的数据。

## 遗忘数据是一个特性

默认情况下，memcached是一个LRU缓存。

它被设计成经过一段时间后数据项会过期。

这两种都是对付许多问题的优雅的解决方案；

几分钟后数据项过期可以限制过期的数据不被返回，或者努力刷掉不用的数据来保留经常被访问的信息。

这进一步地让memcached工作得极其单纯化。

无“暂停”的垃圾收集确保了低延迟，空闲内存空间被懒散地回收。

## 缓存失效是一个难题

考虑到memcached的集中成一个集群的特性，使缓存条目无效化的工作相当烦琐。

不是广播数据到所有可用的主机，而是客户端直接接手数据无效化的工作。

你可能更近一步地卷入到你的需求中去，有许多注意事项，但是你坐在一条强健的基准线上。

## memcached是如何进化演变的？

memcached已经演变成一个平台。

其中一部分原因是缓慢的开发特性以及许多客户端。

更多的在于人们发现了键-值储存的潜力。

学习缓存SQL查询并且渲染模板过去常常花掉了开发者的空闲时光，但是他们渴望更多。

## 协议

memcached不是这个协议的唯一实现。

还有有商业实体、其他的OSS项目等。

memcached 客户端相当的通用，像memcached一样的集群布局有许多用途。

我们将会继续看到其他的项目“说”memcached，这反过来影响作为一个文化和软件本身的memcached.

## 其他协议

业界正在试验许多不同的与网络化的服务进行通讯的方法。

Google Protocol Buffers、Facebook Thrift、Avro 等。

以后可能会有更优的方式来达到这目的。

## 永久性储存

许多用户希望键-值存储能在重启后仍存留值，或者超过可用的物理内存。

在许多情况下memcached不是特别合适；

需要昂贵的闪存来保持数据访问的良好性能。

大部分情景下，如果一个服务器不可用后来给出了旧数据那么灾难将会紧随其后。

用户看到陈旧的数据、功能破裂等等。

然而随着SSD价格的下降，这将是一个有可能扩展的领域。

## 存储引擎

一般来说，作为服务的存储引擎是memcached的未来。

除了我们可敬的切块算法，还有其他的内存后端可用于试验。

tcmalloc、jemalloc、CPU-local切块、hierachies等。

存储引擎促进了提升速度与内存效率的试验，也促进了专业服务支持memcached协议。